{
    "collab_server" : "",
    "contents" : "# Aufgabe: Generating species richness data GBIF requires several steps: \n# rgbif geogr. correction, R::taxis, sampling bias, richness\n# This project builds the pipiline for future use.\n\n##\n## Install required packages\n##\n# install.packages(\"sp\")\n# install.packages(\"raster\")\n# install.packages(\"XML\")\n# install.packages(\"lattice\")\n# install.packages(\"grid\")\n# install.packages(\"foreign\")\n# install.packages(\"maptools\")\n# install.packages(\"dismo\")\n# install.packages(\"curl\")\n# install.packages(\"httr\")\n# install.packages(\"rgeos\")\n# install.packages(\"rgbif\")\n# install.packages(\"taxize\")\n# install.packages(\"rgdal\")\n# install.packages(\"devtools\")\n# install.packages(\"doParallel\")\n# install.packages(\"doSNOW\")\n# \n# # taxize soap extension for taxize utilizing soap to access the web service\n# # by World register of marine species (worms)\n# install.packages(\n#  c(\"XMLSchema\", \"SSOAP\"), \n#  repos = c(\"http://packages.ropensci.org\", \n#            \"http://cran.rstudio.com\"))\n# devtools::install_github(\"ropensci/taxizesoap\")\n\n##\n## Load required Packages\n##\nlibrary(sp)\nlibrary(raster)\nlibrary(XML)\nlibrary(lattice)\nlibrary(grid)\nlibrary(foreign)\nlibrary(maptools) \nlibrary(rgbif)    # doc: https://cran.r-project.org/web/packages/rgbif/rgbif.pdf\nlibrary(dismo)\nlibrary(rgdal)\nlibrary(utils)\nlibrary(devtools)\nlibrary(foreach)\nlibrary(doParallel)\nlibrary(doSNOW)\nlibrary(rgeos)\nlibrary(taxizesoap)\n\n##\n## Initialize and setup environment\n##\n\n#' Loading data from the gbif database\n#' @param species_name Specify the name of the species in order to download the\n#'   data from the gbif database\n#' @param start Specify the start index to begin the download with\n#' @param limit Specify the number of occurrences to download (max: 200.000)\ninitData <- function(species_name, start = 0, limit = 200) {\n  occ <- occ_search(scientificName = species_name, limit = limit, \n                    hasCoordinate = TRUE, start = start)\n  return (occ)\n}\n\n#' Get the number of occurrences for a specific species\n#' @param species_name Name of the species to load\n#' @return species$meta$count - The number of occurrences for the specified \n#'   species\ngetNumberOfOccurences <- function(species_name) {\n  species <- initData(species_name = species_name, start = 0, limit = 1)\n  return (species$meta$count)\n}\n\n#' Get the species properties from the worms database to check marine species\n#' with failing location check\n#' @param species_name Name of the species to get the properties for\n#' @return speciesOpts - habitat properties of the named species\ngetSpeciesOpts <- function(species_name) {\n  # query the worms database for habitat\n  worms <- worms_records(scientific=species_name)\n  # setup a list with species properties\n  speciesOpts <- list()\n  if (NROW(worms) == 0 && NCOL(worms) == 0) {\n    speciesOpts$isMarine <- 0\n  } else {\n    speciesOpts$isMarine <- max(worms$isMarine, na.rm = TRUE)\n  }\n  return (speciesOpts)\n}\n\n#' Download spatial data from natural earth and unzip it\ninitLocation <- function() {\n  # load all countries of the world\n  countries_name <- \"countries.zip\"\n  if (!file.exists(\"countries.zip\")) {\n    download.file(url = paste(\"http://www.naturalearthdata.com/http//\",\n                              \"www.naturalearthdata.com/download/50m/cultural/\",\n                              \"ne_50m_admin_0_countries.zip\", sep = \"\"), \n                  destfile = countries_name)\n    unzip(countries_name)\n  }\n}\n\n#' Read the shape file utilizing the rgdal package\nopenShape <- function() {\n  # check for supported file formats\n  ogrDrivers()\n  # open vector file (esri-shapeformat)\n  countries <- try(readOGR(dsn=\"ne_50m_admin_0_countries.shp\"))\n  # out <- crop(countries, extent(-20, 45, 30, 50))\n  out <- countries\n  plot(out, col = \"gainsboro\", lwd = 0.2)\n  return (countries)\n}\n\n##\n## Processing methods for iterative use\n##\n\n#' Checks if lat, long locations concurs with country codes. Checks lat, long \n#' if lat, long lies within country shape\n#' @param current_occ_chunk One data chunk from gbif containing occurences\n#' @param countries Dataset of all countries in the world provided by \n#'   natural earth.\n#' @return check_result: Boolean values indicating if the locations of the \n#'   occurences are in the given countries - true - correct, false - incorrect\ncheckLocation <- function(current_occ_chunk, countries) {\n  \n  # create empty result container\n  # by default the points and the countries do not match\n  check_result <- logical(NROW(current_occ_chunk$data))\n  \n  # access location parameter from current original occurence\n  lat <- current_occ_chunk$data$decimalLatitude\n  long <- current_occ_chunk$data$decimalLongitude\n  countryCode <- current_occ_chunk$data$countryCode\n  \n  # create spatial point from lat, long\n  current_occ_points <- SpatialPointsDataFrame(cbind(long, lat), \n                                               data = current_occ_chunk$data)\n  # reproject points and countries to global metric projection\n  # using pseudo transmercator projection\n  proj4string(current_occ_points) <- proj4string(countries)\n  current_occ_points_3857 <- spTransform(current_occ_points, \n                                         CRS(\"+init=epsg:3857\"))\n  countries_3857 <- spTransform(countries, CRS(\"+init=epsg:3857\"))\n  \n  # Use buffer arround the countries to match also the points which are \n  # inaccurate and lie at the coast side\n  # positive buffer for terrestial species which are located in the sea\n  # negative buffer for marine species which are located on land\n  if (species_opts$isMarine == 0) {\n    country_buffer_3857 <- gBuffer(countries_3857, width = 10000, byid = TRUE)\n  } else if (species_opts$isMarine == 1) {\n    country_buffer_3857 <- gBuffer(countries_3857, width = -10000, byid = TRUE)\n  }\n  # Check all points from a chunk against all countries\n  intersectingPolygons <- over(current_occ_points_3857, country_buffer_3857)\n  \n  # Marine check\n  nonIntersectingPoints_idx <- which(is.na(intersectingPolygons$type))\n  intersectingPoints_idx <- which(!is.na(intersectingPolygons$type))\n  \n  # not intersecting points\n  if (species_opts$isMarine == 1) { # Marine species only live in the sea\n    check_result[nonIntersectingPoints_idx] <- TRUE\n    check_result[intersectingPoints_idx] <- FALSE\n  } else { # Terrestial species only live on land\n    check_result[nonIntersectingPoints_idx] <- FALSE\n    check_result[intersectingPoints_idx] <- TRUE\n    \n    # get indexes from country codes which are not NA\n    valid_CountryCodes_idx <- which(!is.na(countryCode))\n    # get indexes from polygon iso codes which are not NA\n    valid_PolygonIsoCodes_idx <- which(!is.na(intersectingPolygons$iso_a2))\n    # combine the two indices to get all valid intersections\n    valid_idx <- intersect(valid_CountryCodes_idx, valid_PolygonIsoCodes_idx)\n    # check iso and country codes for valid indices\n    check_result[valid_idx] <- countryCode[valid_idx] == \n      intersectingPolygons[valid_idx,]$iso_a2\n  }\n  return (check_result)\n}\n\n#' Tries to correct the locations by swapping the sign of lat, long, latlong & \n#' checks if the lat long of the point concurs the country shape with the \n#' country code\n#' @param current_occ_chunk One chunk of several gbif occurence\n#' @param countries Dataset of all countries in the world provided by \n#'   natural earth.\n#' @return current_occ_chunk_corrected: Corrected or unchanged but flagged \n#'   occurences\ncorrectSign <- function(current_occ_chunk, countries) {\n  # prepare temporal correction for each check\n  corrected_current_occ_chunk_lat <- current_occ_chunk\n  corrected_current_occ_chunk_long <- current_occ_chunk\n  corrected_current_occ_chunk_latlong <- current_occ_chunk\n  \n  # access original location parameter from current occurence\n  lat <- current_occ_chunk$data$decimalLatitude\n  long <- current_occ_chunk$data$decimalLongitude\n  \n  # apply correction\n  # swapped lat\n  corrected_current_occ_chunk_lat$data$decimalLatitude <- -1 * lat\n  # swapped long\n  corrected_current_occ_chunk_long$data$decimalLongitude <- -1 * long\n  # swapped lat and long\n  corrected_current_occ_chunk_latlong$data$decimalLatitude <- -1 * lat\n  corrected_current_occ_chunk_latlong$data$decimalLongitude <- -1 * long\n  \n  # recheck location for each modification\n  isCorrectedLocationLatCorrect <- checkLocation(\n    current_occ_chunk = corrected_current_occ_chunk_lat, countries = countries)\n  isCorrectedLocationLongCorrect <- checkLocation(\n    current_occ_chunk = corrected_current_occ_chunk_long, countries = countries)\n  isCorrectedLocationLatLongCorrect <- checkLocation(\n    current_occ_chunk = corrected_current_occ_chunk_latlong, \n    countries = countries)\n  current_occ_chunk_corrected <- current_occ_chunk\n  \n  # indices of corrected occurences for each modification\n  lat_correct_idx <- which(isCorrectedLocationLatCorrect)\n  long_correct_idx <- which(isCorrectedLocationLongCorrect)\n  latlong_correct_idx <- which(isCorrectedLocationLatLongCorrect)\n  \n  # adopt corrected and checked modification to the original data and flag\n  # modification for each type of modification.\n  # set initial correction flag to incorrect data (3) - change modification flag\n  # if modification is adopted (2)\n  current_occ_chunk_corrected$data$correction_flag <- 3\n  if (length(lat_correct_idx) > 0) { # adopt lat modification\n    current_occ_chunk_corrected$data[lat_correct_idx,] <- \n      corrected_current_occ_chunk_lat$data[lat_correct_idx,]\n    current_occ_chunk_corrected$data[lat_correct_idx,]$correction_flag <- 2\n  } else if (length(long_correct_idx) > 0) { # adopt long modification\n    current_occ_chunk_corrected$data[long_correct_idx,] <- \n      corrected_current_occ_chunk_long$data[long_correct_idx,]\n    current_occ_chunk_corrected$data[long_correct_idx,]$correction_flag <- 2\n  } else if (length(latlong_correct_idx) > 0) { # adopt latlong modification\n    current_occ_chunk_corrected$data[latlong_correct_idx,] <- \n      corrected_current_occ_chunk_latlong$data[latlong_correct_idx,]\n    current_occ_chunk_corrected$data[latlong_correct_idx,]$correction_flag <- 2\n  } \n  return (current_occ_chunk_corrected)\n}\n\n#' Checks if point with lat & long would concure in country shape with country\n#' code if lat and long are swapped; \n#' switched lat/long cannot exceed the dimension of valid lat/long numbers \n#' @param current_occ_chunk One data chunk from gbif containing occurences\n#' @param countries Dataset of all countries in the world provided by \n#'   natural earth.\n#' @return current_occ_chunk_corrected: Corrected or unchanged but flagged \n#'   occurences\ncorrectSwap <- function(current_occ_chunk, countries) {\n  \n  corrected_current_occ_chunk_swapped <- current_occ_chunk\n  \n  # access original location parameter from current occurence\n  lat <- current_occ_chunk$data$decimalLatitude\n  long <- current_occ_chunk$data$decimalLongitude\n  \n  # swap lat long only if swap does not exceed bounding box of \n  # coordinate system.\n  valid_lat_idx <- which(long <= 90 && long >= -90)\n  \n  # actual swap\n  corrected_current_occ_chunk_swapped$data$decimalLatitude[valid_lat_idx] <- \n    long[valid_lat_idx]\n  corrected_current_occ_chunk_swapped$data$decimalLongitude[valid_lat_idx] <- \n    lat[valid_lat_idx]\n  \n  # recheck location\n  isCorrectedLocationSwapCorrect <- checkLocation(\n    current_occ_chunk = corrected_current_occ_chunk_swapped, \n    countries = countries)\n  \n  current_occ_chunk_corrected <- current_occ_chunk\n  \n  # get indices of corrected and checked data\n  swap_correct_idx <- which(isCorrectedLocationSwapCorrect)\n  \n  # adopt corrected and checked data to original chunk\n  if (length(swap_correct_idx) > 0) {\n    current_occ_chunk_corrected$data[swap_correct_idx,] <- \n      corrected_current_occ_chunk_swapped$data[swap_correct_idx,]\n    current_occ_chunk_corrected$data[swap_correct_idx,]$correction_flag <- 2\n  }\n  return (current_occ_chunk_corrected)\n}\n\n#' Checks if point with lat & long would concure in country shape with country\n#' code if lat and long AND the signs of lat and long (* -1) are switched; \n#' switched lat/long cannot exceed the dimension of valid lat/long coordinates\n#' @param current_occ_chunk One data chunk from gbif containing occurences\n#' @param countries Dataset of all countries in the world provided by \n#'   natural earth.\n#' @return current_occ_chunk_corrected: Corrected or unchanged but flagged \n#'   occurences\ncorrectSignSwap <- function(current_occ_chunk, countries) {\n  corrected_current_occ_chunk_sign_swapped <- current_occ_chunk\n  \n  # access original location parameter from current occurence\n  lat <- current_occ_chunk$data$decimalLatitude\n  long <- current_occ_chunk$data$decimalLongitude\n  \n  # swap lat long only if swap does not exceed bounding box of \n  # coordinate system.\n  valid_lat_idx <- which(long <= 90 && long >= -90)\n  \n  # actual lat long swap\n  corrected_current_occ_chunk_sign_swapped$data$\n    decimalLatitude[valid_lat_idx] <- long[valid_lat_idx]\n  corrected_current_occ_chunk_sign_swapped$data$\n    decimalLongitude[valid_lat_idx] <- lat[valid_lat_idx]\n  \n  # apply swapped data to sign correction\n  corrected_current_occ_chunk_sign_swapped <- \n    correctSign(corrected_current_occ_chunk_sign_swapped, countries)\n  \n  # recheck location\n  isCorrectedLocationSwapCorrect <- checkLocation(\n    current_occ_chunk = corrected_current_occ_chunk_sign_swapped, \n    countries = countries)\n  \n  current_occ_chunk_corrected <- current_occ_chunk\n  \n  # get indices of corrected and checked data\n  swap_correct_idx <- which(isCorrectedLocationSwapCorrect)\n  \n  # adopt corrected and checked data to original chunk\n  if (length(swap_correct_idx) > 0) {\n    current_occ_chunk_corrected$data[swap_correct_idx,] <- \n      corrected_current_occ_chunk_sign_swapped$data[swap_correct_idx,]\n    current_occ_chunk_corrected$data[swap_correct_idx,]$correction_flag <- 2\n  }\n  return (current_occ_chunk_corrected)\n}\n\n#' Prepares pipline check and enables the three different output-modes:\n#' strict (delete errorneous data), \n#' correction (try to correct the data),\n#' uncertain (flag errorneous data but dont correct)\n#' @param fun Function to apply to the pipeline and work according to correction\n#'   level.\n#' @param current_occ_chunk Original chunk of occurences before correction and \n#'   flagging. Might be preprocessed data from a previous check.\n#' @return current_occ_chunk_corrected: Corrected or unchanged but flagged \n#'   occurences\npipeline_generic_check <- function(fun, current_occ_chunk) {\n  current_occ_chunk_corrected <- current_occ_chunk\n\n  # make an initial location check\n  isLocationCorrect <- checkLocation(\n    current_occ_chunk = current_occ_chunk, countries = countries)\n  # get the indices of the incorrect records which have to be corrected\n  locationIncorrect_idx <- which(!isLocationCorrect)\n  # apply different modification or correction modi\n  if (length(locationIncorrect_idx) > 0) { # Location is incorrect\n    if (correction_level == 3) { # strict mode\n      current_occ_chunk_corrected$data[locationIncorrect_idx,] <- NA\n    } else if (correction_level == 2) { # correction mode\n      # correct only terrestial data, because it can be checked against\n      # iso or country codes\n      if (species_opts$isMarine == 0) {\n        correctedLocations <- fun(\n          current_occ_chunk = current_occ_chunk, countries = countries)\n        current_occ_chunk_corrected$data[locationIncorrect_idx,] <- \n          correctedLocations$data[locationIncorrect_idx,]\n      } else {\n        current_occ_chunk_corrected$data[locationIncorrect_idx,]$\n          correction_flag <- 3\n      }\n    } else if (correction_level == 1) { # uncertain flag mode\n      current_occ_chunk_corrected$data[locationIncorrect_idx,]$\n        correction_flag <- 4\n    }\n  }\n  return (current_occ_chunk_corrected)\n}\n\n#' Feeding pipline (consinsting of the defined functions) with current_occ_chunk\n#' and receiving the output result (with corrected or flagged output)\n#' @param current_occ_chunk\n#' @return current_occ_chunk_corrected: Corrected or unchanged but flagged \n#'   occurences\npipeline <- function(current_occ_chunk) {\n  current_occ_chunk_corrected <- current_occ_chunk\n  current_occ_chunk_corrected$data$correction_flag <- 1\n  \n  # apply the different kind of correction to the data passing the pipeline\n  # sign correction\n  current_occ_chunk_corrected <- pipeline_generic_check(\n    fun = correctSign, current_occ_chunk = current_occ_chunk_corrected)\n  # swap correction\n  current_occ_chunk_corrected <- pipeline_generic_check(\n    fun = correctSwap, current_occ_chunk = current_occ_chunk_corrected)\n  # sign + swap correction\n  current_occ_chunk_corrected <- pipeline_generic_check(\n    fun = correctSignSwap, current_occ_chunk = current_occ_chunk_corrected)\n  \n  return (current_occ_chunk_corrected)\n}\n\n#' Plot one occurence based on the correction_flag\n#' @param current_occ Current occurence for plotting\n#' @param countries countries Dataset of all countries in the world provided by\n#'   natural earth.\nplotPoint <- function(occ, countries) {\n  for (i in 1:NROW(occ)) {\n    current_occ <- occ[i,]$data\n    # access location parameter from current occurence\n    lat <- current_occ$decimalLatitude\n    long <- current_occ$decimalLongitude\n    if (!is.na(lat) || !is.na(long)) {\n      # create point from lat, long\n      current_occ_point <- SpatialPoints(cbind(long, lat))\n      proj4string(current_occ_point) <- proj4string(countries)\n      points(current_occ_point, col = \n               ifelse(current_occ$correction_flag == 1,'#0571b0',\n                      ifelse(current_occ$correction_flag == 2, \"cyan\",\n                             ifelse(current_occ$correction_flag == 3, \"#ca0020\", \n                                    \"#f4a582\"))), pch = 'Â·', cex=2)\n    }\n  }\n}\n\n#' Main loop to iterate over all occurences with variables chunks \n#' (variable in size an number)\n#' @param species_name Name of the species to download the occurences\n#' @param countries All countries of the world from shapefile to make \n#'   location checks.\n#' @param correction_level A number defining the level of correction:\n#'   1 - flag (flag and dont correct invalid data), \n#'   2 - correct (flag and correct invalid data), \n#'   3 - strict (remove invalid data)\n#' @return correctedData - Checked and corrected location gbif data\nmainLoop <- function(species_name, countries, correction_level, \n                     records_per_chunk, number_of_records, species_opts, \n                     progressbar = TRUE) {\n  number_of_chunks <- ceiling(number_of_records / records_per_chunk)\n  print(paste(\"Number of chunks: \", number_of_chunks))\n  \n  # set up progress bar\n  if(progressbar) {\n    pb <- txtProgressBar(min = 0, max = number_of_chunks, style = 3)\n    progress <- function(n) setTxtProgressBar(pb, n)\n    opts <- list(progress = progress)\n  }\n  # use all cores available, except 1\n  cores <- parallel::detectCores() - 1\n  # set up computation cluster\n  cl <- parallel::makeCluster(cores)\n  doSNOW::registerDoSNOW(cl)\n\n  correctedData <- \n    foreach::foreach(i = 0:number_of_chunks, .combine = rbind, \n     .options.snow = opts, .export = \n       c(\"initData\", \"pipeline\", \"checkLocation\", \n         \"countries\", \"correction_level\", \"correctSign\", \n         \"correctSwap\", \"correctSignSwap\", \"species_opts\", \n         \"pipeline_generic_check\"),\n     .packages = c(\"rgbif\", \"rgeos\", \"sp\")) %dopar% {\n       \n       # Load gbif data\n       current_occ_chunk <- initData(\n         species_name = species_name, \n         start = i * records_per_chunk, \n         limit = (i + 1) * records_per_chunk - 1)\n       \n       if (is.null(current_occ_chunk$data)) {\n         stop(\"No data found!\")\n       }\n       # start the pipeline\n       corrected_data <- pipeline(current_occ_chunk = current_occ_chunk)\n    }\n  # stop cluster, free memory form workers\n  parallel::stopCluster(cl = cl)\n  close(pb)\n  return (correctedData)\n}\n\n#' entry point of the package and decide for level of correction\n#' @param correction_level A number defining the level of correction:\n#'   1 - flag (flag and dont correct invalid data), \n#'   2 - correct (flag and correct invalid data), \n#'   3 - strict (remove invalid data)\n#' @param species_name\n#' @param limit\nstartup <- function(species_name, number_of_records, records_per_chunk, \n                    correction_level = 2) {\n  correction_level <- correction_level\n  # Load shape file\n  initLocation()\n  countries <- openShape()\n  \n  # Load species properties from worms\n  species_opts <- getSpeciesOpts(species_name)\n  \n  # start parallelized loop to iterate over chunks containing a subset of all \n  # occurences\n  result <- mainLoop(species_name = species_name,  countries = countries, \n                     correction_level = correction_level,\n                     records_per_chunk = records_per_chunk, \n                     number_of_records = number_of_records,\n                     species_opts = species_opts)\n  # plot the whole composed result\n  plotPoint(occ = result, countries = countries)\n}\n\n# do some testing\n# startup(species_name = \"Ursus americanus\", records_per_chunk = 250, number_of_records = 1000,\n#         correction_level = 2)\n# startup(species_name = \"Chamaerops humilis\", records_per_chunk = 200, number_of_records = 4000,\n#         correction_level = 2)\n# startup(species_name = \"Scardinius erythrophthalmus\", records_per_chunk = 200, number_of_records = 500,\n#         correction_level = 2)\n# startup(species_name = \"Pygocentrus piraya\", records_per_chunk = 1, number_of_records = 1,\n#         correction_level = 2)\n# startup(species_name = \"Balaenoptera musculus\", records_per_chunk = 200, number_of_records = 4000,\n#         correction_level = 2)\n# startup(species_name = \"Delphinus delphis\", records_per_chunk = 200, number_of_records = 4000,\n#         correction_level = 2)\n# startup(species_name = \"Xenial xerus\", records_per_chunk = 200, number_of_records = 4000,\n#         correction_level = 2)",
    "created" : 1481727873690.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3228794325",
    "id" : "A97C8DA5",
    "lastKnownWriteTime" : 1481727311,
    "last_content_update" : 1481727311,
    "path" : "~/GBIFsiteChecker/R/occurence_access.r",
    "project_path" : "R/occurence_access.r",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}